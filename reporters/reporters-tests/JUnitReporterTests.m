
#import <SenTestingKit/SenTestingKit.h>

#import "JUnitReporter.h"
#import "Reporter+Testing.h"

@interface JUnitReporterTests : SenTestCase
@end

@implementation JUnitReporterTests

- (void)testTestResults {
  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
  
  NSError *error = nil;
  
  NSData *outputData =
    [JUnitReporter outputDataWithEventsFromFile:TEST_DATA @"JSONStreamReporter-runtests.txt"];
  
  NSXMLDocument *actualOutput = [[NSXMLDocument alloc] initWithData:outputData options:0 error:&error];
  if (error) {
    STFail(@"Error parsing the actual JUnit reporter output XML:\n%@", error);
    [pool drain];
    return;
  }

  NSString *expectedFilePath = TEST_DATA @"JSONStreamReporter-expected.xml";
  expectedOutput = [[NSXMLDocument alloc] initWithData:[NSData dataWithContentsOfFile:expectedFilePath] options:0 error:&error];
  if (error) {
    STFail(@"Error opening file %@ the expected XML for this unit test:\n%@", expectedFilePath, error);
    [pool drain];
    return;
  }

  for (NSXMLDocument *doc in @[expectedOutput, actualOutput]) {

    // Remove the "time" attribute values, and "timestamp" attribute values.
    for (NSString *attributeName in @[@"time", @"timestamp"]) {
      NSString *xpath = [NSString stringWithFormat:@"//*[@%@]", attributeName];
      NSArray *elementsWithTimeAttr = [doc nodesForXPath:xpath error:&error];
      if (error) {
        STFail(@"Error while searching for time-related nodes using XPath.");
        [pool drain];
        return;
      }
      for (NSXMLElement *element in elementsWithTimeAttr) {
        [element removeAttributeForName:attributeName];
        [element addAttribute:[NSXMLNode attributeWithName:attributeName stringValue:@""]];
      }
    }
    
    // Strip leading & trailing whitespace in each line of the <system-out> tags
    NSArray *systemOutElements = [doc nodesForXPath:@"//system-out" error:&error];
    if (error) {
      STFail(@"Error while searching for <system-out> nodes using Xpath.");
      [pool drain];
      return;
    }
    for (NSXMLElement *systemOutElement in systemOutElements) {
      STAssertEquals([systemOutElement childCount], (NSUInteger) 1, @"A <system-out> tag has %d children, but should have 1. Element in question: %@", [systemOutElement childCount], systemOutElement);
      NSXMLNode *innerText = [systemOutElement childAtIndex:0];
      STAssertEquals([innerText kind], NSXMLTextKind, @"There is a non-text type inside the <system-out> tag.");
      NSArray *lines = [[innerText stringValue] componentsSeparatedByString:@"\n"];
      NSMutableArray *resultingLines = [[NSMutableArray alloc] init];
      for (NSString *line in lines) {
        NSString *trimmed = line;
        NSRange range = [trimmed rangeOfString:@"^\\s*" options:NSRegularExpressionSearch];
        if (range.location != NSNotFound) {
          trimmed = [trimmed stringByReplacingCharactersInRange:range withString:@""];
        }
        range = [trimmed rangeOfString:@"\\s*$" options:NSRegularExpressionSearch];
        if (range.location != NSNotFound) {
          trimmed = [trimmed stringByReplacingCharactersInRange:range withString:@""];
        }
        if ([trimmed isEqualToString:@""])
          [resultingLines addObject:trimmed];
      }
      NSXMLNode *trimmedInnerText = [[NSXMLNode alloc] initWithKind:NSXMLTextKind];
      [trimmedInnerText setStringValue:[resultingLines componentsJoinedByString:@"\n"]];
      [systemOutElement replaceChildAtIndex:0 withNode:trimmedInnerText];
      [trimmedInnerText release];
      [resultingLines release];
    }
    
  }
  
  STAssertEqualObjects(expectedOutput, actualOutput, @"The XML doc generated by the JUnit Reporter differs from the one expected by this test.");
//  NSArray *expectedNodes = [[expectedOutput rootElement] children];
//  NSArray *actualNodes = [[actualOutput rootElement] children];
////  STAssertEqualObjects([expectedOutput rootElement], [actualOutput rootElement], @"The root elements differ.");
//  STAssertEquals([expectedNodes count], [actualNodes count], @"Derp");
//  for (NSUInteger i = 0; i < [expectedNodes count]; ++i) {
//    NSXMLNode *expectedNode = expectedNodes[i];
//    NSXMLNode *actualNode = actualNodes[i];
//    if (![expectedNode isEqual:actualNode]) {
//      STFail(@"Failed on iteration: %d\n\nexpected:\n%@\n\nactual:\n%@", i, expectedNode, actualNode);
//    }
//  }
  [pool drain];
}

@end